const STACK_LIMIT=16384;class ManagedMemory{constructor(e){this.memory=e,this.uview=new Uint32Array(e.buffer),this.runtime=null,this.markedSet=0,this.requiredSize=0,this._refreshViews=this._refreshViews.bind(this),this.malloc=this.malloc.bind(this),this.sizeLimits=[6,8,0],this.freeLists=[0,0,STACK_LIMIT],this.numFreeLists=3;let t=this.uview.byteLength>>2;this.setSize(STACK_LIMIT,t-STACK_LIMIT)}_refreshViews(){this.uview=new Uint32Array(this.memory.buffer)}setRuntime(e){this.runtime=e}log(e){return console.log("log:",e),e}getListIndex(e){return Math.min(e/2-3,2)}getNextTail(e){return-2&this.uview[e-1]}getPrev(e){return-2&this.uview[e]}setPrev(e,t){this.uview[e]=t}isAllocated(e){return 1&this.uview[e]}isAllocatedTail(e){return 1&this.uview[e-1]}setAllocated(e,t){this.uview[e]|=1,this.uview[e+t-1]|=1}getSize(e){return-2&this.uview[e+1]}getSizeTail(e){return this.uview[e-2]}setSize(e,t){this.uview[e+1]=t,this.uview[e+t-2]=t}isMarked(e){return 1&this.uview[e+1]}setMarked(e){this.uview[e+1]|=1}clearMarked(e){this.uview[e+1]&=-2}linkAfter(e,t){this.uview[e-1]=t,0!==t&&(this.uview[t]=e)}growHeap(e){let t=4*e+65535>>16;const i=this.memory.buffer.byteLength>>2;if(-1===this.memory.grow(t))throw"Could not allocate memory";this._refreshViews(),this.setSize(i,t<<14),this.free(i)}removeFromList(e,t,i){0!=t?this.linkAfter(t,i):(0!=i&&this.setPrev(i,t),this.freeLists[e]=i)}removeFromUnknownList(e,t,i){if(0!=t)this.linkAfter(t,i);else{0!=i&&this.setPrev(i,t);for(let t=0;t<this.numFreeLists;t++)if(this.freeLists[t]==e)return void(this.freeLists[t]=i)}}insertIntoList(e,t){let i=this.getListIndex(t);this.setPrev(e,0),this.linkAfter(e+t,this.freeLists[i]),this.freeLists[i]=e}malloc(e){const t=2*(2+(e+8-1>>3));for(let e=this.getListIndex(t);e<this.numFreeLists;e++){this.numScans++;let i=this.freeLists[e];if(0==i)continue;let s=e>0?this.sizeLimits[e-1]:0,r=i,h=this.getSize(r);if(h>=t){let i=this.getNextTail(r+h);if(h<=t+4)0!==i&&this.setPrev(i,0),this.freeLists[e]=i;else{let l=h-t;this.setSize(r,l),l<=s?(this.removeFromList(e,0,i),this.insertIntoList(r,l)):this.linkAfter(r+l,i),r+=l,h=t,this.setSize(r,t)}return this.setAllocated(r,h),r+2<<2}let l=r,n=h;for(r=this.getNextTail(l+n);0!==r;){h=this.getSize(r);let i=this.getNextTail(r+h);if(h>=t){if(h<=t+4)this.linkAfter(l+n,i);else{let o=h-t;this.setSize(r,o),o<=s?(this.removeFromList(e,l+n,i),this.insertIntoList(r,o)):this.linkAfter(r+o,i),r+=o,h=t,this.setSize(r,t)}return this.setAllocated(r,h),r+2<<2}l=r,n=h,r=i}}return this.requiredSize=t,this.doGC(),(this.requiredSize>0||this.dataFreed<256)&&this.growHeap(t),this.malloc(e)}free(e){let t=this.getSize(e);if(this.dataFreed+=t,e+t<this.uview.byteLength>>2&&!this.isAllocated(e+t)){let i=e+t,s=this.getSize(i),r=this.getNextTail(i+s),h=this.getPrev(i);this.removeFromUnknownList(i,h,r),t+=s,this.setSize(e,t)}if(e>STACK_LIMIT&&!this.isAllocatedTail(e)){let i=this.getSizeTail(e),s=e-i,r=this.getListIndex(i),h=this.getListIndex(i+t),l=this.getNextTail(e);r===h?(this.linkAfter(e+t,l),t+=i,this.setSize(s,t)):(t+=i,this.setSize(s,t),this.removeFromList(r,this.getPrev(s),l),this.insertIntoList(s,t))}else this.insertIntoList(e,t);t>=this.requiredSize&&(this.requiredSize=0)}pushMarkedSet(e){this.setMarked(e),this.setPrev(e,1|this.markedSet),this.markedSet=e}popMarkedSet(){let e=this.markedSet;return this.markedSet=this.getPrev(e),e}markReference(e){if(1&e){let t=(e>>2)-2;this.isMarked(t)||this.pushMarkedSet(t)}}mark(){let e=this.runtime.exports.sp.value>>2;for(let t=0;t<e;t++)this.markReference(this.uview[t]);for(;this.markedSet>1;){let e=this.popMarkedSet(),t=this.uview[e+3];for(let i=0;i<t;i++)this.markReference(this.uview[e+i+4])}}sweep(){const e=this.memory.buffer.byteLength>>2;let t=STACK_LIMIT;for(;t<e;){let e=this.getSize(t);this.isAllocated(t)&&(this.isMarked(t)?this.clearMarked(t):this.free(t)),t+=e}}doGC(){this.dataFreed=0,this.mark(),this.sweep()}stackLimitExceeded(){throw"Maximum stack size exceeded"}}exports.ManagedMemory=ManagedMemory;